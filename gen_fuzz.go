package main

import (
	"fmt"
	"go/types"
	"golang.org/x/tools/go/packages"
	"io/ioutil"
	"os"
	"reflect"
	"strings"
	"text/template"
)

//var(
//	tag="gofuzz"
//)
var fuzzSrc = template.Must(template.New("Fuzz").Parse(`
package {{.pkg}}

import (
	fuzz "github.com/google/gofuzz"
)

func Fuzz(data []byte) int {
	{{- range $i, $v := .inputs}}
	var {{index $v 0}} {{index $v 1}}
	{{- end}}

	f := fuzz.NewFromGoFuzz(data).NilChance(0)
	{{- range $i, $v := .inputs}}
	f.Fuzz(&{{index $v 0}})
	{{- end}}

	{{.pkg}}.{{.funcName}}(
	{{- $first := true}}
	{{- range $i, $v := .inputs}}
	{{- if $first}}
		{{- $first = false}}
	{{- else -}}
		,
	{{- end}}
	{{- index $v 0}}
	{{- end}})
	return 0
}
`))


// Context holds state for a gen-fuzz run. (This is copied from go-fuzz project)
type Context struct {
	targetFuncObj types.Object
	inputs [][]string
	pkgs    []*packages.Package // type-checked root packages

	std    map[string]bool // set of packages in the standard library
	ignore map[string]bool // set of packages to ignore during instrumentation

	allFuncs []string // all fuzz functions found in package

	workdir string
	GOROOT  string
	GOPATH  string

	cpuprofile *os.File

	cmdGoHasTrimPath bool // does the active version of cmd/go have the -trimpath flag?
}

func basePackagesConfig() *packages.Config {
	cfg := new(packages.Config)
	cfg.Env = os.Environ()
	return cfg
}


// TODO: checkout whether to add the cleanup function
func (c *Context) failf(str string, args ...interface{}) {
	//c.cleanup()
	_, err := fmt.Fprintf(os.Stderr, str+"\n", args...)
	if err != nil {
		return
	}
	os.Exit(1)
}


// TODO: if this function is overwriting the file, change it to append to the file
func (c *Context) writeFile(name string, data []byte) {
	if err := ioutil.WriteFile(name, data, 0700); err != nil {
		c.failf("failed to write temp file: %v", err)
	}
}


func (c *Context)parseFunc(){
	// Output is [][]string containing name and type of the function's input
	// such as {{"var1", "string"}, {"var2", "int32"}}
	//var res [][]string
	funcInfo := c.targetFuncObj.Type().String()  // such as func(var1 string, var2 int32)
	inputStr := ""
	i := strings.Index(funcInfo, "(")
	if i >= 0 {
		j := strings.Index(funcInfo[i:], ")")
		if j >= 0 {
			inputStr = funcInfo[i+1 : i+j]
		}
	}
	if inputStr == ""{
		c.failf("no inputStr found from the given function info: %v", funcInfo)
	}
	inputs := strings.Split(inputStr, ",")

	for _, input := range inputs{
		inputVar := strings.Split(strings.TrimSpace(input), " ")
		fmt.Printf("inputVar: %v\n", inputVar)
		c.inputs = append(c.inputs, []string{inputVar[0], inputVar[1]})
	}
	fmt.Printf("inputs==: %v\n", c.inputs)
	//c.inputs = res
}


func (c *Context) loadFuncObj(pkg string, funcName string){
	// Resolve pkg.
	cfg := basePackagesConfig()
	cfg.Mode = packages.NeedName | packages.NeedTypes
	//cfg.BuildFlags = []string{"-tags", tag}
	pkgs, err := packages.Load(cfg, pkg)
	if err != nil {
		c.failf("could not resolve package %q: %v", pkg, err)
	}
	if len(pkgs) != 1 {
		paths := make([]string, len(pkgs))
		for i, p := range pkgs {
			paths[i] = p.PkgPath
		}
		c.failf("cannot build multiple packages, but %q resolved to: %v", pkg, strings.Join(paths, ", "))
	}
	if pkgs[0].Name == "main" {
		c.failf("cannot fuzz package main")
	}

	// Get the target function object
	targetFuncObj :=  pkgs[0].Types.Scope().Lookup(funcName)
	if targetFuncObj == nil{
		c.failf("didn't find function %v under package %v\n", pkg, funcName)
	}
	if targetFuncObjType := reflect.TypeOf(targetFuncObj).Elem(); targetFuncObjType != reflect.TypeOf(types.Func{}){
		c.failf("the kind of %v should be a func, but resolved to %v", funcName, targetFuncObjType)
	}
	c.targetFuncObj = targetFuncObj
}


func main(){
	// Example command: gen-fuzz -dir=./ -funcName=Add -out=Fuzz
	c := new(Context)
	//TODO: add flag to get pkgDir and funcName
	pkgDir := "./"
	funcName := "GetNext"
	c.loadFuncObj(pkgDir, funcName)

	c.parseFunc()
	fmt.Printf("input types: %v\n", c.inputs)
	pkgName := c.targetFuncObj.Pkg().Name()
	fmt.Printf("pkg name: %v\nfuncName: %v\ninputs: %v\n", pkgName, funcName, c.inputs)

	fmt.Printf("=====Generated Func=====")
	varMap := map[string]interface{}{"pkg": pkgName, "funcName": funcName, "inputs": c.inputs}
	temp := fuzzSrc
	//TODO: output the template to a file (how to append to the file?)
	if err := temp.Execute(os.Stderr, varMap); err != nil {
		c.failf("could not execute template: %v", err)
	}
}

//future todos
//TODO:
// 1. Not all inputs should be generated by gofuzz, let user to define some of them. (golang command)
// 2. Also need to
// 3. Automatically run go-fuzz on the generated file (need to go-fuzz-build first)
// [4. Automatically generate unit test from the inputs that made the function crush.]
//(not really, because most likely there are already unit tests)]
